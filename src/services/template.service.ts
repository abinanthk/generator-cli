import { join } from 'path';
import { ensureDir, readdir, stat } from 'fs-extra';
import { TemplateContext, TemplateInfo, TemplateError } from '../types';
import { FileUtil, TemplateUtil, logger } from '../utils';

export class TemplateService {
  private readonly defaultTemplatesDir = join(__dirname, '../templates');
  private readonly customTemplatesDir = join(process.cwd(), 'templates');

  async initializeTemplate(type: string): Promise<void> {
    await ensureDir(this.customTemplatesDir);
    
    const templateContent = this.getDefaultTemplate(type);
    const templatePath = join(this.customTemplatesDir, `${type}.hbs`);
    
    await FileUtil.writeTextFile(templatePath, templateContent);
    logger.info(`Template initialized: ${templatePath}`);
  }

  async listTemplates(): Promise<TemplateInfo[]> {
    const templates: TemplateInfo[] = [];
    
    // List default templates
    const defaultTemplates = this.getDefaultTemplatesList();
    templates.push(...defaultTemplates);
    
    // List custom templates if directory exists
    if (await FileUtil.fileExists(this.customTemplatesDir)) {
      try {
        const files = await readdir(this.customTemplatesDir);
        const customTemplates = files
          .filter(file => file.endsWith('.hbs'))
          .map(file => ({
            name: file.replace('.hbs', ''),
            type: file.replace('.hbs', '') as any,
            description: `Custom ${file.replace('.hbs', '')} template`,
            path: join(this.customTemplatesDir, file),
          }));
        
        templates.push(...customTemplates);
      } catch (error) {
        logger.warn('Failed to read custom templates directory');
      }
    }
    
    return templates;
  }

  async renderTemplate(templateType: string, context: TemplateContext): Promise<string> {
    // Try custom template first, then fall back to default
    const customTemplatePath = join(this.customTemplatesDir, `${templateType}.hbs`);
    
    if (await FileUtil.fileExists(customTemplatePath)) {
      logger.debug(`Using custom template: ${customTemplatePath}`);
      return this.renderFromFile(customTemplatePath, context);
    }
    
    logger.debug(`Using default template for: ${templateType}`);
    return this.renderDefaultTemplate(templateType, context);
  }

  private async renderFromFile(templatePath: string, context: TemplateContext): Promise<string> {
    try {
      const templateContent = await FileUtil.readJsonFile<string>(templatePath);
      return TemplateUtil.compileTemplateString(templateContent, context);
    } catch (error) {
      throw new TemplateError(`Failed to render template: ${templatePath}`, error);
    }
  }

  private renderDefaultTemplate(templateType: string, context: TemplateContext): string {
    const templateContent = this.getDefaultTemplate(templateType);
    return TemplateUtil.compileTemplateString(templateContent, context);
  }

  private getDefaultTemplate(type: string): string {
    switch (type) {
      case 'constants':
        return this.getConstantsTemplate();
      case 'models':
        return this.getModelsTemplate();
      case 'services':
        return this.getServicesTemplate();
      case 'queries':
        return this.getQueriesTemplate();
      case 'mutations':
        return this.getMutationsTemplate();
      default:
        throw new TemplateError(`Unknown template type: ${type}`);
    }
  }

  private getDefaultTemplatesList(): TemplateInfo[] {
    return [
      {
        name: 'constants',
        type: 'constants',
        description: 'API endpoint constants template',
        path: 'built-in',
      },
      {
        name: 'models',
        type: 'models',
        description: 'TypeScript model interfaces template',
        path: 'built-in',
      },
      {
        name: 'services',
        type: 'services',
        description: 'Axios API service template',
        path: 'built-in',
      },
      {
        name: 'queries',
        type: 'queries',
        description: 'React Query hooks template',
        path: 'built-in',
      },
    ];
  }

  private getConstantsTemplate(): string {
    return `// Auto-generated API constants for {{tag}} tag
// ðŸš€ Generated by generator-cli

{{#each constants}}
export const {{uppercase tag}}_ENDPOINTS = {
{{#each endpoints}}
  {{methodComment method}}
  {{uppercase name}}: {
    path: '{{path}}',
    method: '{{method}}' as const,
  },
{{/each}}
} as const;

{{/each}}

// Type definitions for endpoints
{{#each constants}}
export type {{pascalCase tag}}Endpoints = typeof {{uppercase tag}}_ENDPOINTS;
{{/each}}
`;
  }

  private getModelsTemplate(): string {
    return `// Auto-generated model interfaces
// ðŸš€ Generated by generator-cli

{{#each models}}
{{#if description}}
/**
 * {{description}}
 */
{{/if}}
export interface {{modelName}} {
{{#each (parseJSON properties)}}
  {{#if this.description}}
  /** {{this.description}} */
  {{/if}}
  {{@key}}{{#unless (includes ../required @key)}}?{{/unless}}: {{#if (eq this.type "array")}}{{#if this.items}}{{#if this.items.type}}{{this.items.type}}{{else}}any{{/if}}[]{{else}}any[]{{/if}}{{else if (eq this.type "object")}}{{#if this.properties}}{ {{#each this.properties}}{{@key}}: {{this.type}}; {{/each}} }{{else}}Record<string, any>{{/if}}{{else}}{{this.type}}{{/if}};
{{/each}}
}

{{/each}}`;
  }

  private getServicesTemplate(): string {
    return `// Auto-generated API service for {{tag}} tag
// ðŸš€ Generated by generator-cli

import axios, { AxiosResponse } from 'axios';
{{#if operations}}
{{#each operations}}
{{#if requestBodyRef}}
import { {{requestBodyRef}} } from '../models/{{kebabCase tag}}';
{{/if}}
{{#if responseBodyRef}}
import { {{responseBodyRef}} } from '../models/{{kebabCase tag}}';
{{/if}}
{{#if queryParamsRef}}
import { {{queryParamsRef}} } from '../models/{{kebabCase tag}}';
{{/if}}
{{/each}}
{{/if}}

const API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || 'http://localhost:3000/api';

export class {{pascalCase tag}}Service {
{{#each operations}}
  /**
   * {{summary}}
   {{#if businessPurpose}}
   * Purpose: {{businessPurpose}}
   {{/if}}
   */
  static async {{camelCaseName}}(
    {{#if pathParams}}pathParams: { {{#each pathParams}}{{@key}}: {{type}}; {{/each}} },{{/if}}
    {{#if queryParamsRef}}queryParams?: {{queryParamsRef}},{{/if}}
    {{#if requestBodyRef}}data: {{requestBodyRef}},{{/if}}
    config?: any
  ): Promise<AxiosResponse<{{#if responseBodyRef}}{{responseBodyRef}}{{else}}any{{/if}}>> {
    {{#if pathParams}}
    let url = \`\${API_BASE_URL}{{endpoint}}\`;
    {{#each pathParams}}
    url = url.replace('{{{@key}}}', String(pathParams.{{@key}}));
    {{/each}}
    {{else}}
    const url = \`\${API_BASE_URL}{{endpoint}}\`;
    {{/if}}

    return axios.{{lowercase method}}<{{#if responseBodyRef}}{{responseBodyRef}}{{else}}any{{/if}}>(
      url,
      {{#if (eq method "GET")}}
      {{#if queryParamsRef}}
      { params: queryParams, ...config }
      {{else}}
      config
      {{/if}}
      {{else}}
      {{#if requestBodyRef}}data,{{else}}undefined,{{/if}}
      {
        {{#if queryParamsRef}}params: queryParams,{{/if}}
        ...config
      }
      {{/if}}
    );
  }

{{/each}}
}
`;
  }

  private getQueriesTemplate(): string {
    return `// Auto-generated React Query hook
// ðŸš€ Generated by generator-cli

import { useQuery, UseQueryOptions, UseQueryResult } from '@tanstack/react-query';
{{#each operations}}
{{#if responseBodyRef}}
import { {{responseBodyRef}} } from '../../models/{{kebabCase tag}}';
{{/if}}
{{#if queryParamsRef}}
import { {{queryParamsRef}} } from '../../models/{{kebabCase tag}}';
{{/if}}
{{/each}}
import { {{pascalCase tag}}Service } from '../../services/{{kebabCase tag}}.service';

{{#each operations}}
/**
 * {{summary}}
 {{#if businessPurpose}}
 * Purpose: {{businessPurpose}}
 {{/if}}
 */
export const use{{pascalCaseName}}Query = (
  {{#if pathParams}}pathParams: { {{#each pathParams}}{{@key}}: {{type}}; {{/each}} },{{/if}}
  {{#if queryParamsRef}}queryParams?: {{queryParamsRef}},{{/if}}
  options?: Omit<UseQueryOptions<{{#if responseBodyRef}}{{responseBodyRef}}{{else}}any{{/if}}>, 'queryKey' | 'queryFn'>
): UseQueryResult<{{#if responseBodyRef}}{{responseBodyRef}}{{else}}any{{/if}}> => {
  return useQuery({
    queryKey: [
      '{{kebabCase tag}}', 
      '{{kebabCaseName}}'
      {{#if pathParams}}, pathParams{{/if}}
      {{#if queryParamsRef}}, queryParams{{/if}}
    ],
    queryFn: () => {{pascalCase tag}}Service.{{camelCaseName}}(
      {{#if pathParams}}pathParams,{{/if}}
      {{#if queryParamsRef}}queryParams{{/if}}
    ).then(response => response.data),
    {{#if requiresAuth}}
    enabled: !!authToken, // Requires authentication
    {{/if}}
    ...options,
  });
};

{{/each}}`;
  }

  private getMutationsTemplate(): string {
    return `// Auto-generated React Mutation hook
// ðŸš€ Generated by generator-cli

import { useMutation, UseMutationOptions, UseMutationResult } from '@tanstack/react-query';
{{#each operations}}
{{#if requestBodyRef}}
import { {{requestBodyRef}} } from '../../models/{{kebabCase tag}}';
{{/if}}
{{#if responseBodyRef}}
import { {{responseBodyRef}} } from '../../models/{{kebabCase tag}}';
{{/if}}
{{#if queryParamsRef}}
import { {{queryParamsRef}} } from '../../models/{{kebabCase tag}}';
{{/if}}
{{/each}}
import { {{pascalCase tag}}Service } from '../../services/{{kebabCase tag}}.service';

{{#each operations}}
interface {{pascalCaseName}}Variables {
  {{#if pathParams}}pathParams: { {{#each pathParams}}{{@key}}: {{type}}; {{/each}} };{{/if}}
  {{#if queryParamsRef}}queryParams?: {{queryParamsRef}};{{/if}}
  {{#if requestBodyRef}}data: {{requestBodyRef}};{{/if}}
}

/**
 * {{summary}}
 {{#if businessPurpose}}
 * Purpose: {{businessPurpose}}
 {{/if}}
 */
export const use{{pascalCaseName}}Mutation = (
  options?: UseMutationOptions<
    {{#if responseBodyRef}}{{responseBodyRef}}{{else}}any{{/if}}, 
    Error, 
    {{pascalCaseName}}Variables
  >
): UseMutationResult<
  {{#if responseBodyRef}}{{responseBodyRef}}{{else}}any{{/if}}, 
  Error, 
  {{pascalCaseName}}Variables
> => {
  return useMutation({
    mutationFn: async (variables: {{pascalCaseName}}Variables) => {
      const response = await {{pascalCase tag}}Service.{{camelCaseName}}(
        {{#if pathParams}}variables.pathParams,{{/if}}
        {{#if queryParamsRef}}variables.queryParams,{{/if}}
        {{#if requestBodyRef}}variables.data{{/if}}
      );
      return response.data;
    },
    ...options,
  });
};

{{/each}}`;
  }
}